{"_id": "PVFormMacro", "name": "Form Party", "type": "script", "author": null, "img": "icons/svg/users.svg", "scope": "global", "command": "// MACRO: Form Party - Choose Leader\nconst selectedTokens = canvas.tokens.controlled;\n\nif (selectedTokens.length < 1) {\n  return ui.notifications.warn(\"Please select one or more player tokens to form a party.\");\n}\n\n// Check if tokens have actors\nconst tokensWithActors = selectedTokens.filter(t => t.actor);\nif (tokensWithActors.length === 0) {\n  return ui.notifications.error(\"Selected tokens have no linked actors!\");\n}\n\nif (tokensWithActors.length < selectedTokens.length) {\n  ui.notifications.warn(`${selectedTokens.length - tokensWithActors.length} token(s) skipped (no actor).`);\n}\n\n// If only one token, just form party\nif (tokensWithActors.length === 1) {\n  return ui.notifications.warn(\"Need at least 2 tokens to form a party.\");\n}\n\n// Show leader selection dialog\nconst leaderOptions = tokensWithActors.map((t, idx) => \n  `<option value=\"${idx}\">${t.name}${idx === 0 ? ' (First Selected)' : ''}</option>`\n).join('');\n\nnew Dialog({\n  title: \"Form Party - Choose Leader\",\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>Choose which token should be the \"front\" of the party:</label>\n        <select name=\"leaderIndex\" style=\"width: 100%; padding: 5px; margin: 10px 0;\">\n          ${leaderOptions}\n        </select>\n        <p style=\"font-size: 0.9em; color: #999;\">\n          The leader will be at the front when deploying. Other tokens maintain their relative positions.\n        </p>\n      </div>\n    </form>\n  `,\n  buttons: {\n    form: {\n      label: \"Form Party\",\n      callback: async (html) => {\n        const leaderIndex = parseInt(html.find('[name=\"leaderIndex\"]').val()) || 0;\n        const leaderToken = tokensWithActors[leaderIndex];\n        \n        await createParty(tokensWithActors, leaderToken);\n      }\n    },\n    cancel: { label: \"Cancel\" }\n  },\n  default: \"form\"\n}).render(true);\n\nasync function createParty(tokens, leader) {\n  const gridSize = canvas.scene.grid.size;\n  \n  // Use LEADER'S position as the center\n  const centerX = leader.center.x;\n  const centerY = leader.center.y;\n  \n  // Find max dimensions\n  let maxWidth = 1;\n  let maxHeight = 1;\n  for (const token of tokens) {\n    if (token.document.width > maxWidth) maxWidth = token.document.width;\n    if (token.document.height > maxHeight) maxHeight = token.document.height;\n  }\n  \n  // Build member data relative to LEADER's position\n  const partyMembers = tokens.map(token => {\n    const deltaX = token.center.x - centerX;\n    const deltaY = token.center.y - centerY;\n    const gridX = Math.round(deltaX / gridSize);\n    const gridY = Math.round(deltaY / gridSize);\n    return {\n      actorId: token.actor.id,\n      actorUuid: token.actor.uuid, // Store UUID for better linking\n      dx: gridX,\n      dy: gridY,\n      name: token.name,\n      isLeader: token.id === leader.id\n    };\n  });\n  \n  // Place party token at LEADER'S position (snapped to grid)\n  const snapX = Math.round((leader.x) / gridSize) * gridSize;\n  const snapY = Math.round((leader.y) / gridSize) * gridSize;\n  \n  const partyTokenData = {\n    name: `The Party`,\n    x: snapX,\n    y: snapY,\n    texture: { src: \"icons/svg/users.svg\" },\n    width: maxWidth,\n    height: maxHeight,\n    sight: {\n      enabled: true,\n      range: 0,\n      angle: 360,\n      visionMode: \"basic\"\n    },\n    displayName: CONST.TOKEN_DISPLAY_MODES.ALWAYS,\n    actorLink: false,\n    disposition: CONST.TOKEN_DISPOSITIONS.FRIENDLY,\n    flags: {\n      \"party-vision\": {\n        \"memberData\": partyMembers,\n        \"lastFacing\": -Math.PI / 2  // Default: North\n      }\n    }\n  };\n  \n  await canvas.scene.createEmbeddedDocuments(\"Token\", [partyTokenData]);\n  await canvas.scene.deleteEmbeddedDocuments(\"Token\", tokens.map(t => t.id));\n  \n  const leaderName = leader.name;\n  ui.notifications.info(`Party formed with ${partyMembers.length} members! Leader: ${leaderName}`);\n}\n", "folder": null, "sort": 0, "ownership": {"default": 0}, "flags": {}, "_stats": {"systemId": null, "systemVersion": null, "coreVersion": null, "createdTime": null, "modifiedTime": null, "lastModifiedBy": null}}
{"_id": "PVDeployMacro", "name": "Deploy Party", "type": "script", "author": null, "img": "icons/svg/users-slash.svg", "scope": "global", "command": "// MACRO: Deploy Party - Fixed Actor Linking\nconst partyToken = canvas.tokens.controlled[0];\n\nif (!partyToken) {\n  return ui.notifications.warn(\"Please select the Party Token to deploy.\");\n}\n\nconst memberData = partyToken.document.getFlag(\"party-vision\", \"memberData\");\nif (!memberData) {\n  return ui.notifications.warn(\"This is not a valid Party Token.\");\n}\n\n// Find the leader\nconst leaderData = memberData.find(m => m.isLeader) || memberData[0];\n\nnew Dialog({\n  title: `Deploy Party (Leader: ${leaderData.name})`,\n  content: `\n    <div style=\"padding: 10px;\">\n      <h3 style=\"margin-top: 0;\">Leader: ${leaderData.name}</h3>\n      <p>Choose deployment direction:</p>\n      <div class=\"direction-grid\" style=\"display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; margin: 15px auto; max-width: 200px;\">\n        <div class=\"direction-btn empty\" style=\"visibility: hidden;\"></div>\n        <div class=\"direction-btn\" data-direction=\"north\" title=\"North\" style=\"padding: 15px; border: 2px solid #444; border-radius: 5px; cursor: pointer; text-align: center; background: rgba(0,0,0,0.3);\">\n          <i class=\"fas fa-arrow-up\" style=\"font-size: 24px;\"></i>\n        </div>\n        <div class=\"direction-btn empty\" style=\"visibility: hidden;\"></div>\n        <div class=\"direction-btn\" data-direction=\"west\" title=\"West\" style=\"padding: 15px; border: 2px solid #444; border-radius: 5px; cursor: pointer; text-align: center; background: rgba(0,0,0,0.3);\">\n          <i class=\"fas fa-arrow-left\" style=\"font-size: 24px;\"></i>\n        </div>\n        <div class=\"direction-btn empty\" style=\"visibility: hidden;\"></div>\n        <div class=\"direction-btn\" data-direction=\"east\" title=\"East\" style=\"padding: 15px; border: 2px solid #444; border-radius: 5px; cursor: pointer; text-align: center; background: rgba(0,0,0,0.3);\">\n          <i class=\"fas fa-arrow-right\" style=\"font-size: 24px;\"></i>\n        </div>\n        <div class=\"direction-btn empty\" style=\"visibility: hidden;\"></div>\n        <div class=\"direction-btn\" data-direction=\"south\" title=\"South\" style=\"padding: 15px; border: 2px solid #444; border-radius: 5px; cursor: pointer; text-align: center; background: rgba(0,0,0,0.3);\">\n          <i class=\"fas fa-arrow-down\" style=\"font-size: 24px;\"></i>\n        </div>\n        <div class=\"direction-btn empty\" style=\"visibility: hidden;\"></div>\n      </div>\n    </div>\n  `,\n  buttons: {\n    deploy: {\n      label: \"Deploy\",\n      callback: async (html) => {\n        const selectedDirection = html.find('.direction-btn.selected').data('direction') || 'north';\n        \n        const directionMap = {\n          north: -Math.PI / 2,\n          east: 0,\n          south: Math.PI / 2,\n          west: Math.PI\n        };\n        \n        const radians = directionMap[selectedDirection];\n        await partyToken.document.setFlag('party-vision', 'lastFacing', radians);\n        await deployPartyNow(partyToken, memberData, radians);\n      }\n    },\n    cancel: { label: \"Cancel\" }\n  },\n  default: \"deploy\",\n  render: (html) => {\n    html.find('.direction-btn:not(.empty)').on('click', function() {\n      html.find('.direction-btn').removeClass('selected');\n      $(this).addClass('selected');\n      $(this).css({\n        'border-color': '#00ff88',\n        'background': 'rgba(0, 255, 136, 0.2)'\n      });\n    });\n    \n    // Select north by default\n    const defaultBtn = html.find('.direction-btn[data-direction=\"north\"]');\n    defaultBtn.addClass('selected');\n    defaultBtn.css({\n      'border-color': '#00ff88',\n      'background': 'rgba(0, 255, 136, 0.2)'\n    });\n    \n    // Add hover effects\n    html.find('.direction-btn:not(.empty)').hover(\n      function() {\n        if (!$(this).hasClass('selected')) {\n          $(this).css({\n            'border-color': '#0088ff',\n            'background': 'rgba(0, 136, 255, 0.2)',\n            'transform': 'scale(1.05)'\n          });\n        }\n      },\n      function() {\n        if (!$(this).hasClass('selected')) {\n          $(this).css({\n            'border-color': '#444',\n            'background': 'rgba(0, 0, 0, 0.3)',\n            'transform': 'scale(1)'\n          });\n        }\n      }\n    );\n  }\n}).render(true);\n\nasync function deployPartyNow(partyToken, memberData, targetDirection) {\n  const gridSize = canvas.scene.grid.size;\n  const assignedGridSpots = new Set();\n  \n  // Get original facing (when party was formed)\n  const originalFacing = partyToken.document.getFlag('party-vision', 'lastFacing') || (-Math.PI / 2);\n  \n  // Calculate rotation: difference between target and original\n  const rotationAngle = -(targetDirection - originalFacing);\n  const cos = Math.cos(rotationAngle);\n  const sin = Math.sin(rotationAngle);\n  \n  const newTokensData = [];\n  \n  // Sort by distance from center (place center tokens first)\n  const sortedMembers = [...memberData].sort((a, b) => \n    (Math.abs(a.dx) + Math.abs(a.dy)) - (Math.abs(b.dx) + Math.abs(b.dy))\n  );\n  \n  for (const member of sortedMembers) {\n    // Get actor - try UUID first, then ID\n    let actor;\n    if (member.actorUuid) {\n      try {\n        actor = await fromUuid(member.actorUuid);\n      } catch (e) {\n        console.warn(`Party Vision: Could not resolve actor UUID ${member.actorUuid}`);\n      }\n    }\n    \n    if (!actor) {\n      actor = game.actors.get(member.actorId);\n    }\n    \n    if (!actor) {\n      console.warn(`Party Vision: Actor not found for member ${member.name}`);\n      continue;\n    }\n    \n    // Rotate the offset\n    const dx = member.dx;\n    const dy = member.dy;\n    const rotatedX = Math.round(dx * cos - dy * sin);\n    const rotatedY = Math.round(dx * sin + dy * cos);\n    \n    // Calculate target position relative to party token\n    const partyGridX = partyToken.x / gridSize;\n    const partyGridY = partyToken.y / gridSize;\n    const idealGridX = Math.round(partyGridX + rotatedX);\n    const idealGridY = Math.round(partyGridY + rotatedY);\n    \n    // Get fresh token data from actor\n    const protoToken = actor.prototypeToken;\n    const tokenData = protoToken.toObject();\n    \n    // Find valid spot\n    const validSpot = findValidSpot(idealGridX, idealGridY, tokenData, assignedGridSpots);\n    assignedGridSpots.add(`${validSpot.x},${validSpot.y}`);\n    \n    const finalX = validSpot.x * gridSize;\n    const finalY = validSpot.y * gridSize;\n    \n    // CRITICAL: Properly set actor association for PF2e\n    const newToken = {\n      ...tokenData,\n      x: finalX,\n      y: finalY,\n      actorId: actor.id,\n      actorLink: protoToken.actorLink,\n      // Ensure actor data is preserved\n      name: actor.prototypeToken.name || actor.name,\n      img: actor.prototypeToken.texture?.src || actor.img\n    };\n    \n    // Remove any synthetic actor data that might cause issues\n    delete newToken.actorData;\n    delete newToken.delta;\n    \n    newTokensData.push(newToken);\n  }\n  \n  // Create all tokens\n  await canvas.scene.createEmbeddedDocuments(\"Token\", newTokensData);\n  \n  // Delete party token\n  await canvas.scene.deleteEmbeddedDocuments(\"Token\", [partyToken.id]);\n  \n  ui.notifications.info(`Party deployed: ${newTokensData.length} members!`);\n}\n\nfunction findValidSpot(idealX, idealY, tokenData, assignedSpots) {\n  if (isSpotValid(idealX, idealY, tokenData, assignedSpots)) {\n    return { x: idealX, y: idealY };\n  }\n  \n  // Spiral search\n  for (let r = 1; r < 20; r++) {\n    for (let x = idealX - r; x <= idealX + r; x++) {\n      for (let y = idealY - r; y <= idealY + r; y++) {\n        if (Math.abs(x - idealX) !== r && Math.abs(y - idealY) !== r) continue;\n        if (isSpotValid(x, y, tokenData, assignedSpots)) {\n          return { x, y };\n        }\n      }\n    }\n  }\n  \n  console.warn(`Party Vision | No valid spot found near (${idealX}, ${idealY})`);\n  return { x: idealX, y: idealY };\n}\n\nfunction isSpotValid(gridX, gridY, tokenData, assignedSpots) {\n  const gridSize = canvas.scene.grid.size;\n  const finalX = gridX * gridSize;\n  const finalY = gridY * gridSize;\n  \n  if (assignedSpots.has(`${gridX},${gridY}`)) return false;\n  \n  const tokenWidth = tokenData.width * gridSize;\n  const tokenHeight = tokenData.height * gridSize;\n  const centerX = finalX + (tokenWidth / 2);\n  const centerY = finalY + (tokenHeight / 2);\n  \n  // Check walls\n  const testPoints = [\n    { x: centerX, y: centerY },\n    { x: finalX + 5, y: finalY + 5 },\n    { x: finalX + tokenWidth - 5, y: finalY + 5 },\n    { x: finalX + 5, y: finalY + tokenHeight - 5 },\n    { x: finalX + tokenWidth - 5, y: finalY + tokenHeight - 5 }\n  ];\n  \n  for (const point of testPoints) {\n    const collision = canvas.walls.checkCollision(\n      new Ray({ x: point.x - 1, y: point.y - 1 }, { x: point.x + 1, y: point.y + 1 }),\n      { type: \"move\", mode: \"any\" }\n    );\n    if (collision) return false;\n  }\n  \n  // Check token overlaps\n  for (const token of canvas.tokens.placeables) {\n    const tokenRect = {\n      x: token.x,\n      y: token.y,\n      width: token.document.width * gridSize,\n      height: token.document.height * gridSize\n    };\n    const newRect = {\n      x: finalX,\n      y: finalY,\n      width: tokenWidth,\n      height: tokenHeight\n    };\n    \n    if (tokenRect.x < newRect.x + newRect.width &&\n        tokenRect.x + tokenRect.width > newRect.x &&\n        tokenRect.y < newRect.y + newRect.height &&\n        tokenRect.y + tokenRect.height > newRect.y) {\n      return false;\n    }\n  }\n  \n  return true;\n}\n", "folder": null, "sort": 0, "ownership": {"default": 0}, "flags": {}, "_stats": {"systemId": null, "systemVersion": null, "coreVersion": null, "createdTime": null, "modifiedTime": null, "lastModifiedBy": null}}
