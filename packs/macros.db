{"_id": "PVFormMacro", "name": "Form Party", "type": "script", "author": null, "img": "icons/svg/users.svg", "scope": "global", "command": "// MACRO: Form Party - Enhanced with Movement Capabilities\nconst selectedTokens = canvas.tokens.controlled;\n\nif (selectedTokens.length < 1) {\n  return ui.notifications.warn(\"Please select one or more player tokens to form a party.\");\n}\n\n// Check if tokens have actors\nconst tokensWithActors = selectedTokens.filter(t => t.actor);\nif (tokensWithActors.length === 0) {\n  return ui.notifications.error(\"Selected tokens have no linked actors!\");\n}\n\nif (tokensWithActors.length < selectedTokens.length) {\n  ui.notifications.warn(`${selectedTokens.length - tokensWithActors.length} token(s) skipped (no actor).`);\n}\n\n// If only one token, just form party\nif (tokensWithActors.length === 1) {\n  return ui.notifications.warn(\"Need at least 2 tokens to form a party.\");\n}\n\n// Generate a unique key for this party composition (sorted actor IDs)\nconst partyCompositionKey = tokensWithActors\n  .map(t => t.actor.id)\n  .sort()\n  .join(',');\n\n// Try to retrieve saved party configuration\nlet savedPartyConfig = null;\nlet savedLeaderIndex = -1; // -1 means no saved leader\ntry {\n  const allPartyConfigs = game.settings.get('party-vision', 'savedPartyConfigs') || {};\n  savedPartyConfig = allPartyConfigs[partyCompositionKey];\n  \n  console.log('Party Vision | Party Composition Key:', partyCompositionKey);\n  console.log('Party Vision | All Saved Configs:', allPartyConfigs);\n  console.log('Party Vision | Config for this party:', savedPartyConfig);\n  \n  // If we have a saved leader, find their index in the current selection\n  if (savedPartyConfig?.leaderActorId) {\n    const leaderIdx = tokensWithActors.findIndex(t => t.actor.id === savedPartyConfig.leaderActorId);\n    if (leaderIdx !== -1) {\n      savedLeaderIndex = leaderIdx;\n      console.log('Party Vision | Found previous leader at index:', leaderIdx);\n    }\n  }\n} catch (e) {\n  // Settings might not exist yet, use defaults\n  console.warn(\"Party Vision: Could not load saved party configs\", e);\n}\n\n// Use saved values or defaults\nconst defaultName = savedPartyConfig?.name || \"The Party\";\nconst defaultImage = savedPartyConfig?.image || \"icons/svg/users.svg\";\nconst hasSavedConfig = savedPartyConfig !== null;\n\n// Show leader selection dialog\nconst leaderOptions = tokensWithActors.map((t, idx) => {\n  let label = t.name;\n  \n  // Only show \"(Previous Leader)\" if we actually have a saved configuration\n  if (hasSavedConfig && idx === savedLeaderIndex) {\n    label += ' (Previous Leader)';\n  } else if (idx === 0) {\n    label += ' (First Selected)';\n  }\n  \n  const isSelected = hasSavedConfig ? (idx === savedLeaderIndex) : (idx === 0);\n  return `<option value=\"${idx}\"${isSelected ? ' selected' : ''}>${label}</option>`;\n}).join('');\n\nnew Dialog({\n  title: \"Form Party - Configure\",\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>Party Name:</label>\n        <input type=\"text\" name=\"partyName\" value=\"${defaultName}\" style=\"width: 100%; padding: 5px; margin: 5px 0;\">\n      </div>\n      \n      <div class=\"form-group\">\n        <label>Party Token Image:</label>\n        <div style=\"display: flex; align-items: center; gap: 5px; margin: 5px 0;\">\n          <input type=\"text\" name=\"partyImage\" value=\"${defaultImage}\" style=\"flex: 1; padding: 5px;\">\n          <button type=\"button\" class=\"file-picker\" data-type=\"imagevideo\" data-target=\"partyImage\" style=\"flex: 0;\">\n            <i class=\"fas fa-file-import\"></i> Browse\n          </button>\n        </div>\n      </div>\n      \n      <div class=\"form-group\">\n        <label>Choose which token should lead the party:</label>\n        <select name=\"leaderIndex\" style=\"width: 100%; padding: 5px; margin: 10px 0;\">\n          ${leaderOptions}\n        </select>\n        <p style=\"font-size: 0.9em; color: #999;\">\n          The leader is the reference point. Other tokens' positions are stored relative to the leader.\n        </p>\n      </div>\n    </form>\n  `,\n  buttons: {\n    form: {\n      label: \"Form Party\",\n      callback: async (html) => {\n        const leaderIndex = parseInt(html.find('[name=\"leaderIndex\"]').val()) || 0;\n        const leaderToken = tokensWithActors[leaderIndex];\n        const partyName = html.find('[name=\"partyName\"]').val() || \"The Party\";\n        const partyImage = html.find('[name=\"partyImage\"]').val() || \"icons/svg/users.svg\";\n        \n        // Save this party configuration for future use\n        try {\n          const allPartyConfigs = game.settings.get('party-vision', 'savedPartyConfigs') || {};\n          const configToSave = {\n            name: partyName,\n            image: partyImage,\n            leaderActorId: leaderToken.actor.id  // Save leader for future formations\n          };\n          \n          console.log('Party Vision | Saving party configuration:');\n          console.log('  Composition Key:', partyCompositionKey);\n          console.log('  Party Name:', partyName);\n          console.log('  Party Image:', partyImage);\n          console.log('  Leader Actor ID:', leaderToken.actor.id);\n          console.log('  Leader Token Name:', leaderToken.name);\n          \n          allPartyConfigs[partyCompositionKey] = configToSave;\n          await game.settings.set('party-vision', 'savedPartyConfigs', allPartyConfigs);\n          \n          console.log('Party Vision | Configuration saved successfully');\n        } catch (e) {\n          console.error(\"Party Vision: Could not save party configuration\", e);\n        }\n        \n        await createParty(tokensWithActors, leaderToken, partyName, partyImage);\n      }\n    },\n    cancel: { label: \"Cancel\" }\n  },\n  default: \"form\",\n  render: (html) => {\n    // Add file picker functionality\n    html.find('.file-picker').on('click', (event) => {\n      const button = event.currentTarget;\n      const target = button.dataset.target;\n      const inputField = html.find(`[name=\"${target}\"]`)[0];\n      \n      const fp = new FilePicker({\n        type: \"imagevideo\",\n        current: inputField.value,\n        callback: (path) => {\n          inputField.value = path;\n        }\n      });\n      fp.browse();\n    });\n  }\n}).render(true);\n\nasync function createParty(tokens, leader, partyName, partyImage) {\n  const gridSize = canvas.scene.grid.size;\n  \n  // Use LEADER'S CENTER as the reference point\n  const leaderCenterX = leader.center.x;\n  const leaderCenterY = leader.center.y;\n  \n  // Find max dimensions for party token\n  let maxWidth = 1;\n  let maxHeight = 1;\n  for (const token of tokens) {\n    if (token.document.width > maxWidth) maxWidth = token.document.width;\n    if (token.document.height > maxHeight) maxHeight = token.document.height;\n  }\n  \n  // === NEW: Calculate Movement Capabilities ===\n  const movementData = calculateMovementCapabilities(tokens);\n  console.log('Party Vision | Movement capabilities:', movementData);\n  \n  // Build member data with positions relative to leader's CENTER in grid units\n  const partyMembers = tokens.map(token => {\n    // Calculate offset from leader's center to this token's center\n    const deltaX = token.center.x - leaderCenterX;\n    const deltaY = token.center.y - leaderCenterY;\n    \n    // Convert to grid units (fractional grid units for precision)\n    const gridDX = deltaX / gridSize;\n    const gridDY = deltaY / gridSize;\n    \n    // Store original token lighting so we can restore it on deployment\n    const originalLight = {\n      bright: token.document.light?.bright || 0,\n      dim: token.document.light?.dim || 0,\n      angle: token.document.light?.angle || 360,\n      color: token.document.light?.color || null,\n      alpha: token.document.light?.alpha || 0.5,\n      animation: token.document.light?.animation || {},\n      coloration: token.document.light?.coloration || 1,\n      luminosity: token.document.light?.luminosity || 0.5,\n      attenuation: token.document.light?.attenuation || 0.5,\n      contrast: token.document.light?.contrast || 0,\n      saturation: token.document.light?.saturation || 0,\n      shadows: token.document.light?.shadows || 0\n    };\n    \n    return {\n      actorId: token.actor.id,\n      actorUuid: token.actor.uuid,\n      dx: gridDX,  // Grid units east/west offset from leader center\n      dy: gridDY,  // Grid units north/south offset from leader center\n      name: token.name,\n      isLeader: token.id === leader.id,\n      originalLight: originalLight  // Store original lighting\n    };\n  });\n  \n  // Calculate the formation's \"natural facing\" based on leader's position relative to the group\n  // This determines which direction is \"forward\" for this formation\n  const nonLeaderMembers = partyMembers.filter(m => !m.isLeader);\n  let avgNonLeaderX = 0;\n  let avgNonLeaderY = 0;\n  \n  if (nonLeaderMembers.length > 0) {\n    for (const member of nonLeaderMembers) {\n      avgNonLeaderX += member.dx;\n      avgNonLeaderY += member.dy;\n    }\n    avgNonLeaderX /= nonLeaderMembers.length;\n    avgNonLeaderY /= nonLeaderMembers.length;\n  }\n  \n  // The \"forward\" direction is opposite of where the group is relative to the leader\n  // E.g., if the group is west of leader, leader is on the east, so formation faces east\n  const naturalFacing = determineNaturalFacing(-avgNonLeaderX, -avgNonLeaderY);\n  \n  console.log(`Party Vision | Formation natural facing: ${naturalFacing} (group center relative to leader: ${avgNonLeaderX.toFixed(2)}, ${avgNonLeaderY.toFixed(2)})`);\n  \n  \n  // Place party token at LEADER'S position (snapped to grid)\n  let snapX = Math.round(leader.x / gridSize) * gridSize;\n  let snapY = Math.round(leader.y / gridSize) * gridSize;\n  \n  // Check if party token (at its larger size) would collide with walls at this position\n  // This is important when the leader is smaller than other members\n  const idealGridX = snapX / gridSize;\n  const idealGridY = snapY / gridSize;\n  \n  const validPosition = findValidPartyPosition(idealGridX, idealGridY, maxWidth, maxHeight, gridSize, tokens);\n  \n  if (validPosition.displaced) {\n    console.log(`Party Vision | Party token displaced from (${idealGridX}, ${idealGridY}) to (${validPosition.x}, ${validPosition.y}) to avoid walls`);\n    ui.notifications.info(\"Party token position adjusted to avoid walls\");\n    \n    // Recalculate offsets based on new party token position\n    const newSnapX = validPosition.x * gridSize;\n    const newSnapY = validPosition.y * gridSize;\n    const newCenterX = newSnapX + (maxWidth * gridSize / 2);\n    const newCenterY = newSnapY + (maxHeight * gridSize / 2);\n    \n    // Update member offsets relative to new center\n    for (const member of partyMembers) {\n      const token = tokens.find(t => t.actor.id === member.actorId);\n      if (token) {\n        const deltaX = token.center.x - newCenterX;\n        const deltaY = token.center.y - newCenterY;\n        member.dx = deltaX / gridSize;\n        member.dy = deltaY / gridSize;\n      }\n    }\n    \n    snapX = newSnapX;\n    snapY = newSnapY;\n  }\n  \n  // Collect lighting from member tokens\n  const memberLights = [];\n  for (const token of tokens) {\n    if (token.document.light && (token.document.light.bright > 0 || token.document.light.dim > 0)) {\n      memberLights.push({\n        bright: token.document.light.bright || 0,\n        dim: token.document.light.dim || 0,\n        angle: token.document.light.angle || 360,\n        color: token.document.light.color,\n        alpha: token.document.light.alpha || 0.5,\n        animation: token.document.light.animation || {},\n        coloration: token.document.light.coloration || 1,\n        luminosity: token.document.light.luminosity || 0.5,\n        attenuation: token.document.light.attenuation || 0.5,\n        contrast: token.document.light.contrast || 0,\n        saturation: token.document.light.saturation || 0,\n        shadows: token.document.light.shadows || 0\n      });\n    }\n  }\n  \n  // Aggregate lighting (use brightest if multiple lights)\n  let aggregatedLight = {\n    bright: 0,\n    dim: 0,\n    angle: 360,\n    color: null,\n    alpha: 0.5,\n    animation: {},\n    coloration: 1,\n    luminosity: 0.5,\n    attenuation: 0.5,\n    contrast: 0,\n    saturation: 0,\n    shadows: 0\n  };\n  \n  if (memberLights.length > 0) {\n    if (memberLights.length === 1) {\n      aggregatedLight = memberLights[0];\n    } else {\n      // Multiple lights - use the brightest\n      let brightestLight = memberLights[0];\n      let maxRange = memberLights[0].bright + memberLights[0].dim;\n      \n      for (let i = 1; i < memberLights.length; i++) {\n        const range = memberLights[i].bright + memberLights[i].dim;\n        if (range > maxRange) {\n          maxRange = range;\n          brightestLight = memberLights[i];\n        }\n      }\n      \n      aggregatedLight = brightestLight;\n    }\n    \n    console.log(`Party Vision | Applied lighting to party token: bright=${aggregatedLight.bright}, dim=${aggregatedLight.dim}`);\n  }\n  \n  const partyTokenData = {\n    name: partyName,  // Use custom name\n    x: snapX,\n    y: snapY,\n    texture: { src: partyImage },  // Use custom image\n    width: maxWidth,\n    height: maxHeight,\n    sight: {\n      enabled: true,  // Enable sight so the party token respects walls\n      range: 0,  // No base range - will be overridden by individual player vision\n      angle: 360,\n      visionMode: \"basic\"\n    },\n    light: aggregatedLight,  // Apply aggregated lighting from members\n    displayName: CONST.TOKEN_DISPLAY_MODES.ALWAYS,\n    actorLink: false,\n    disposition: CONST.TOKEN_DISPOSITIONS.FRIENDLY,\n    ring: {\n      enabled: false  // Disable ring to avoid visual clutter\n    },\nownership: {\n      default: CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE,\n      ...Object.fromEntries(\n        partyMembers\n          .map(m => game.actors.get(m.actorId))\n          .filter(a => a)\n          .flatMap(a => \n            Object.entries(a.ownership || {})\n              .filter(([userId, level]) => level >= CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER)\n          )\n      )\n    },\n    flags: {\n      \"party-vision\": {\n        \"memberData\": partyMembers,\n        \"naturalFacing\": naturalFacing,  // Which direction is \"forward\" for this formation\n        \"movement\": movementData  // Store movement capabilities\n      }\n    }\n  };\n  \n  // Set locomotion based on available movement types\n  // Foundry VTT recognizes: walk, fly, swim, burrow, climb\n  // System-agnostic approach: use recognized types, default others to walk\n  const foundryLocomotionTypes = ['walk', 'fly', 'swim', 'burrow', 'climb'];\n  \n  if (movementData.types && movementData.types.length > 0) {\n    // Try to find a special movement type (fly, swim, burrow, climb)\n    const specialMovement = movementData.types.find(t => \n      foundryLocomotionTypes.includes(t.toLowerCase()) && t.toLowerCase() !== 'walk'\n    );\n    \n    if (specialMovement) {\n      // Use the special movement type\n      partyTokenData.loco = specialMovement.toLowerCase();\n    } else {\n      // No special movement, or only walk-like movement\n      // Check if any movement type is recognized by Foundry\n      const recognizedType = movementData.types.find(t => \n        foundryLocomotionTypes.includes(t.toLowerCase())\n      );\n      \n      if (recognizedType) {\n        partyTokenData.loco = recognizedType.toLowerCase();\n      } else {\n        // Unknown movement types - assume ground movement\n        partyTokenData.loco = 'walk';\n      }\n    }\n  } else {\n    // No movement types - default to walk\n    partyTokenData.loco = 'walk';\n  }\n  \n  // QOL: Add movement info to token name if setting enabled\n  const showMovementInfo = game.settings.get('party-vision', 'showMovementInfo');\n  if (showMovementInfo && movementData.calculated) {\n    let movementSuffix = ` [${movementData.speed}${movementData.units}`;\n    if (movementData.types.length > 0) {\n      movementSuffix += `, ${movementData.types.join(', ')}`;\n    }\n    movementSuffix += `]`;\n    partyTokenData.name = `${partyName}${movementSuffix}`;\n  }\n  \n  // Create the party token\n  const createdTokens = await canvas.scene.createEmbeddedDocuments(\"Token\", [partyTokenData]);\n  const partyTokenDoc = createdTokens[0];\n\n  // Animate tokens to party center if enabled\n  const shouldAnimate = game.settings.get('party-vision', 'animateDeployment');\n  if (shouldAnimate) {\n    const animationSpeed = game.settings.get('party-vision', 'deploymentAnimationSpeed');\n    const partyTokenObj = canvas.tokens.get(partyTokenDoc.id);\n    \n    if (partyTokenObj) {\n      const partyCenter = {\n        x: partyTokenObj.center.x,\n        y: partyTokenObj.center.y\n      };\n      \n      // Animate all tokens to party center\n      const animations = [];\n      for (const token of tokens) {\n        // Calculate target position (center the token on party center)\n        const targetX = partyCenter.x - (token.document.width * canvas.grid.size / 2);\n        const targetY = partyCenter.y - (token.document.height * canvas.grid.size / 2);\n        \n        animations.push(\n          token.document.update(\n            { x: targetX, y: targetY },\n            { animate: true, animation: { duration: animationSpeed } }\n          )\n        );\n      }\n      \n      // Wait for all animations to complete\n      await Promise.all(animations);\n      \n      // Small delay to ensure animations are visible\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n  }\n\n  // Delete the individual tokens\n  await canvas.scene.deleteEmbeddedDocuments(\"Token\", tokens.map(t => t.id));\n  \n  const leaderName = leader.name;\n  let movementInfo = '';\n  \n  if (movementData.calculated) {\n    movementInfo = `Speed: ${movementData.speed}${movementData.units}`;\n    if (movementData.types.length > 0) {\n      movementInfo += `, Types: ${movementData.types.join(', ')}`;\n    }\n    if (movementData.validMembers < partyMembers.length) {\n      movementInfo += ` (calculated from ${movementData.validMembers}/${partyMembers.length} members)`;\n    }\n  } else {\n    movementInfo = 'Movement calculation disabled';\n  }\n  \n  ui.notifications.info(`Party formed with ${partyMembers.length} members! Leader: ${leaderName}. ${movementInfo}`);\n  \n  console.log(\"Party Vision | Formation stored:\", partyMembers);\n  console.log(\"Party Vision | Movement data:\", movementData);\n}\n\n/**\n * Calculate movement capabilities for the party\n * @param {Array} tokens - Array of tokens in the party\n * @returns {Object} Movement data with speed and available types\n */\nfunction calculateMovementCapabilities(tokens) {\n  // Check if movement calculation is enabled\n  const calculateMovement = game.settings.get('party-vision', 'calculateMovement');\n  if (!calculateMovement) {\n    console.log('Party Vision | Movement calculation disabled in settings');\n    return {\n      speed: 30,\n      types: [],\n      units: 'ft',\n      calculated: false\n    };\n  }\n  \n  let slowestSpeed = Infinity;\n  const allMovementTypes = new Map(); // Map of type -> count of characters with that type\n  let movementUnits = 'ft'; // Default to feet\n  let validSpeedsFound = 0;\n  \n  for (const token of tokens) {\n    const actor = token.actor;\n    \n    // Edge case: Token has no actor\n    if (!actor) {\n      console.warn(`Party Vision | Token \"${token.name}\" has no linked actor, skipping movement calculation for this token`);\n      continue;\n    }\n    \n    // Get movement/speed data - location varies by system\n    // Check multiple common paths for system compatibility\n    let movementData = null;\n    // CRITICAL: Check PF2e v7.5+ path FIRST to avoid deprecated getter\n    if (actor.system?.movement?.speeds) {\n      movementData = actor.system.movement.speeds;\n    } else {\n      // Only check other paths if PF2e path doesn't exist\n      const possiblePaths = [\n        actor.system?.attributes?.movement,  // D&D 5e, many systems\n        actor.system?.attributes?.speed,     // Pathfinder 2e (older), others\n        actor.system?.movement,              // Some systems\n        actor.system?.speed                  // Some systems\n      ];\n      \n      for (const path of possiblePaths) {\n        if (path !== null && path !== undefined) {\n          movementData = path;\n          break;\n        }\n      }\n    }\n    \n    if (!movementData) {\n      console.warn(`Party Vision | Could not find movement/speed data for ${actor.name}`);\n      console.warn(`Party Vision | Checked paths: system.attributes.movement, system.attributes.speed, system.movement, system.speed`);\n      continue;\n    }\n    \n    // Get units if available\n    if (movementData.units) {\n      movementUnits = movementData.units;\n    }\n    \n    // Extract primary speed - check common property names\n    let speed = 0;\n    const speedProperties = ['walk', 'land', 'value', 'base'];\n    \n    for (const prop of speedProperties) {\n      if (movementData[prop] !== undefined) {\n        if (typeof movementData[prop] === 'number') {\n          speed = movementData[prop];\n          break;\n        } else if (typeof movementData[prop] === 'object' && movementData[prop]?.value) {\n          speed = movementData[prop].value;\n          break;\n        }\n      }\n    }\n    \n    // If no named property, check if movementData itself is a number or has value\n    if (speed === 0) {\n      if (typeof movementData === 'number') {\n        speed = movementData;\n      } else if (typeof movementData.value === 'number') {\n        speed = movementData.value;\n      }\n    }\n    \n    // Edge case: Speed is 0 or negative (invalid)\n    if (speed <= 0) {\n      console.warn(`Party Vision | ${actor.name} has invalid speed (${speed}), skipping`);\n      continue;\n    }\n    \n    // Track that we found at least one valid speed\n    validSpeedsFound++;\n    \n    if (speed < slowestSpeed) {\n      slowestSpeed = speed;\n    }\n    \n    // Collect movement types (fly, swim, burrow, climb, etc.)\n    if (typeof movementData === 'object') {\n      for (const [type, value] of Object.entries(movementData)) {\n        // Skip common non-movement properties\n        if (['walk', 'land', 'value', 'base', 'units', 'hover'].includes(type)) continue;\n        \n        let typeSpeed = 0;\n        if (typeof value === 'number') {\n          typeSpeed = value;\n        } else if (typeof value === 'object' && value?.value) {\n          typeSpeed = value.value;\n        }\n        \n        if (typeSpeed > 0) {\n          allMovementTypes.set(type, (allMovementTypes.get(type) || 0) + 1);\n        }\n      }\n    }\n  }\n  \n  // Edge case: No valid speeds found at all\n  if (validSpeedsFound === 0 || slowestSpeed === Infinity) {\n    console.warn('Party Vision | No valid speeds found for any party member, defaulting to 30');\n    slowestSpeed = 30;\n  }\n  \n  // QOL: Round speeds to nearest 5 if setting enabled\n  const shouldRound = game.settings.get('party-vision', 'roundMovementSpeed');\n  if (shouldRound && validSpeedsFound > 0) {\n    slowestSpeed = Math.round(slowestSpeed / 5) * 5;\n    console.log(`Party Vision | Rounded speed to nearest 5: ${slowestSpeed}`);\n  }\n  \n  // Only include movement types that ALL members have\n  const commonMovementTypes = [];\n  const memberCount = tokens.filter(t => t.actor).length; // Only count tokens with actors\n  \n  for (const [type, count] of allMovementTypes.entries()) {\n    if (count === memberCount) {\n      commonMovementTypes.push(type);\n    }\n  }\n  \n  // QOL: Sort movement types alphabetically for consistent display\n  commonMovementTypes.sort();\n  \n  return {\n    speed: slowestSpeed,\n    types: commonMovementTypes,\n    units: movementUnits,\n    calculated: true,\n    validMembers: validSpeedsFound\n  };\n}\n\n/**\n * Determine which direction is \"forward\" based on the leader's position relative to the group\n * @param {number} dx - X component of vector from group center to leader\n * @param {number} dy - Y component of vector from group center to leader\n * @returns {string} Direction: 'north', 'east', 'south', or 'west'\n */\nfunction determineNaturalFacing(dx, dy) {\n  // If leader is isolated (no other members), default to north\n  if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) {\n    return 'north';\n  }\n  \n  // Determine primary direction based on which component is larger\n  const absX = Math.abs(dx);\n  const absY = Math.abs(dy);\n  \n  if (absX > absY) {\n    // Horizontal orientation dominates\n    return dx > 0 ? 'east' : 'west';\n  } else {\n    // Vertical orientation dominates\n    return dy > 0 ? 'south' : 'north';\n  }\n}\n\n/**\n * Find a valid position for the party token, checking for walls and token overlaps\n * @param {number} idealX - Ideal grid X position\n * @param {number} idealY - Ideal grid Y position\n * @param {number} width - Party token width in grid units\n * @param {number} height - Party token height in grid units\n * @param {number} gridSize - Grid size in pixels\n * @param {Array} tokensToExclude - Tokens that will be deleted (don't check against them)\n * @returns {{x: number, y: number, displaced: boolean}} Valid position\n */\nfunction findValidPartyPosition(idealX, idealY, width, height, gridSize, tokensToExclude) {\n  const excludeIds = new Set(tokensToExclude.map(t => t.id));\n  \n  if (isPartyPositionValid(idealX, idealY, width, height, gridSize, excludeIds)) {\n    return { x: idealX, y: idealY, displaced: false };\n  }\n  \n  // Spiral search for nearby valid position\n  for (let r = 1; r < 10; r++) {\n    for (let x = idealX - r; x <= idealX + r; x++) {\n      for (let y = idealY - r; y <= idealY + r; y++) {\n        // Only check perimeter\n        if (Math.abs(x - idealX) !== r && Math.abs(y - idealY) !== r) continue;\n        if (isPartyPositionValid(x, y, width, height, gridSize, excludeIds)) {\n          return { x, y, displaced: true };\n        }\n      }\n    }\n  }\n  \n  // If no valid spot found, use ideal position anyway\n  console.warn(`Party Vision | No valid position found for party token near (${idealX}, ${idealY})`);\n  return { x: idealX, y: idealY, displaced: false };\n}\n\n/**\n * Check if a position is valid for the party token\n * @param {number} gridX - Grid X position\n * @param {number} gridY - Grid Y position\n * @param {number} width - Token width in grid units\n * @param {number} height - Token height in grid units\n * @param {number} gridSize - Grid size in pixels\n * @param {Set} excludeIds - Token IDs to exclude from collision check\n * @returns {boolean} True if position is valid\n */\nfunction isPartyPositionValid(gridX, gridY, width, height, gridSize, excludeIds) {\n  const pixelX = gridX * gridSize;\n  const pixelY = gridY * gridSize;\n  const tokenWidth = width * gridSize;\n  const tokenHeight = height * gridSize;\n  \n  // Check all four corners and center for wall collisions\n  const checkPoints = [\n    { x: pixelX + tokenWidth * 0.25, y: pixelY + tokenHeight * 0.25 },  // Top-left quarter\n    { x: pixelX + tokenWidth * 0.75, y: pixelY + tokenHeight * 0.25 },  // Top-right quarter\n    { x: pixelX + tokenWidth * 0.25, y: pixelY + tokenHeight * 0.75 },  // Bottom-left quarter\n    { x: pixelX + tokenWidth * 0.75, y: pixelY + tokenHeight * 0.75 },  // Bottom-right quarter\n    { x: pixelX + tokenWidth * 0.5, y: pixelY + tokenHeight * 0.5 }     // Center\n  ];\n  \n  // Check if any point collides with walls\n  for (const point of checkPoints) {\n    if (hasWallAtPoint(point, gridSize)) {\n      return false;\n    }\n  }\n  \n  // Check for token overlaps (excluding the tokens we're about to delete)\n  for (const token of canvas.tokens.placeables) {\n    if (excludeIds.has(token.id)) continue; // Skip tokens being formed into party\n    \n    const tokenRect = {\n      x: token.x,\n      y: token.y,\n      width: token.document.width * gridSize,\n      height: token.document.height * gridSize\n    };\n    \n    const partyRect = {\n      x: pixelX,\n      y: pixelY,\n      width: tokenWidth,\n      height: tokenHeight\n    };\n    \n    // AABB collision check\n    if (tokenRect.x < partyRect.x + partyRect.width &&\n        tokenRect.x + tokenRect.width > partyRect.x &&\n        tokenRect.y < partyRect.y + partyRect.height &&\n        tokenRect.y + partyRect.height > partyRect.y) {\n      return false; // Overlap detected\n    }\n  }\n  \n  return true;\n}\n\n/**\n * Check if there's a wall at or very close to a point\n * @param {Object} point - Point to check {x, y}\n * @param {number} gridSize - Grid size in pixels\n * @returns {boolean} True if wall detected at point\n */\nfunction hasWallAtPoint(point, gridSize) {\n  // Check a small radius around the point\n  const checkRadius = gridSize * 0.1; // 10% of grid size\n  \n  for (const wall of canvas.walls.placeables) {\n    // Only check walls that block movement\n    if (wall.document.move === CONST.WALL_SENSE_TYPES.NONE) continue;\n    \n    // Get wall endpoints\n    const wallCoords = wall.document.c;\n    const wallA = { x: wallCoords[0], y: wallCoords[1] };\n    const wallB = { x: wallCoords[2], y: wallCoords[3] };\n    \n    // Calculate distance from point to wall line segment\n    const distance = pointToSegmentDistance(point, wallA, wallB);\n    \n    if (distance < checkRadius) {\n      return true; // Wall too close to this point\n    }\n  }\n  \n  return false;\n}\n\n/**\n * Calculate distance from a point to a line segment\n * @param {Object} point - Point {x, y}\n * @param {Object} segmentStart - Segment start {x, y}\n * @param {Object} segmentEnd - Segment end {x, y}\n * @returns {number} Distance in pixels\n */\nfunction pointToSegmentDistance(point, segmentStart, segmentEnd) {\n  const px = point.x;\n  const py = point.y;\n  const x1 = segmentStart.x;\n  const y1 = segmentStart.y;\n  const x2 = segmentEnd.x;\n  const y2 = segmentEnd.y;\n  \n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  \n  if (dx === 0 && dy === 0) {\n    // Segment is a point\n    return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);\n  }\n  \n  // Calculate parameter t that represents projection of point onto line\n  const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy)));\n  \n  // Calculate closest point on segment\n  const closestX = x1 + t * dx;\n  const closestY = y1 + t * dy;\n  \n  // Return distance from point to closest point on segment\n  return Math.sqrt((px - closestX) ** 2 + (py - closestY) ** 2);\n}\n\n", "folder": null, "sort": 0, "ownership": {"default": 0}, "flags": {}, "_stats": {"systemId": null, "systemVersion": null, "coreVersion": null, "createdTime": null, "modifiedTime": null, "lastModifiedBy": null}}
{"_id": "PVDeployMacro", "name": "Deploy Party", "type": "script", "author": null, "img": "icons/svg/users-slash.svg", "scope": "global", "command": "// MACRO: Deploy Party - Treats Formation as Pure Relative Positions\nconst partyToken = canvas.tokens.controlled[0];\n\nif (!partyToken) {\n  return ui.notifications.warn(\"Please select the Party Token to deploy.\");\n}\n\nconst memberData = partyToken.document.getFlag(\"party-vision\", \"memberData\");\nif (!memberData) {\n  return ui.notifications.warn(\"This is not a valid Party Token.\");\n}\n\n// Find the leader\nconst leaderData = memberData.find(m => m.isLeader) || memberData[0];\n\n// Show deployment dialog with direction options\nnew Dialog({\n  title: `Deploy Party (Leader: ${leaderData.name})`,\n  content: `\n    <div style=\"padding: 10px;\">\n      <h3 style=\"margin-top: 0;\">Leader: ${leaderData.name}</h3>\n      <p>Choose deployment direction:</p>\n      <p style=\"font-size: 0.9em; color: #999; margin: 10px 0;\">\n        The formation will maintain its shape, oriented in the chosen direction.\n      </p>\n      <div class=\"direction-grid\" style=\"display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; margin: 15px auto; max-width: 200px;\">\n        <div class=\"direction-btn empty\" style=\"visibility: hidden;\"></div>\n        <div class=\"direction-btn\" data-direction=\"north\" title=\"North\" style=\"padding: 15px; border: 2px solid #444; border-radius: 5px; cursor: pointer; text-align: center; background: rgba(0,0,0,0.3);\">\n          <i class=\"fas fa-arrow-up\" style=\"font-size: 24px;\"></i>\n        </div>\n        <div class=\"direction-btn empty\" style=\"visibility: hidden;\"></div>\n        <div class=\"direction-btn\" data-direction=\"west\" title=\"West\" style=\"padding: 15px; border: 2px solid #444; border-radius: 5px; cursor: pointer; text-align: center; background: rgba(0,0,0,0.3);\">\n          <i class=\"fas fa-arrow-left\" style=\"font-size: 24px;\"></i>\n        </div>\n        <div class=\"direction-btn empty\" style=\"visibility: hidden;\"></div>\n        <div class=\"direction-btn\" data-direction=\"east\" title=\"East\" style=\"padding: 15px; border: 2px solid #444; border-radius: 5px; cursor: pointer; text-align: center; background: rgba(0,0,0,0.3);\">\n          <i class=\"fas fa-arrow-right\" style=\"font-size: 24px;\"></i>\n        </div>\n        <div class=\"direction-btn empty\" style=\"visibility: hidden;\"></div>\n        <div class=\"direction-btn\" data-direction=\"south\" title=\"South\" style=\"padding: 15px; border: 2px solid #444; border-radius: 5px; cursor: pointer; text-align: center; background: rgba(0,0,0,0.3);\">\n          <i class=\"fas fa-arrow-down\" style=\"font-size: 24px;\"></i>\n        </div>\n        <div class=\"direction-btn empty\" style=\"visibility: hidden;\"></div>\n      </div>\n    </div>\n  `,\n  buttons: {\n    deploy: {\n      label: \"Deploy\",\n      callback: async (html) => {\n        const selectedDirection = html.find('.direction-btn.selected').data('direction') || 'north';\n        await deployPartyNow(partyToken, memberData, selectedDirection);\n      }\n    },\n    cancel: { label: \"Cancel\" }\n  },\n  default: \"deploy\",\n  render: (html) => {\n    html.find('.direction-btn:not(.empty)').on('click', function() {\n      html.find('.direction-btn').removeClass('selected');\n      $(this).addClass('selected');\n      $(this).css({\n        'border-color': '#00ff88',\n        'background': 'rgba(0, 255, 136, 0.2)'\n      });\n    });\n    \n    // Select north by default (formation deploys as originally formed)\n    const defaultBtn = html.find('.direction-btn[data-direction=\"north\"]');\n    defaultBtn.addClass('selected');\n    defaultBtn.css({\n      'border-color': '#00ff88',\n      'background': 'rgba(0, 255, 136, 0.2)'\n    });\n    \n    // Add hover effects\n    html.find('.direction-btn:not(.empty)').hover(\n      function() {\n        if (!$(this).hasClass('selected')) {\n          $(this).css({\n            'border-color': '#0088ff',\n            'background': 'rgba(0, 136, 255, 0.2)',\n            'transform': 'scale(1.05)'\n          });\n        }\n      },\n      function() {\n        if (!$(this).hasClass('selected')) {\n          $(this).css({\n            'border-color': '#444',\n            'background': 'rgba(0, 0, 0, 0.3)',\n            'transform': 'scale(1)'\n          });\n        }\n      }\n    );\n  }\n}).render(true);\n\nasync function deployPartyNow(partyToken, memberData, direction) {\n  const gridSize = canvas.scene.grid.size;\n  const assignedGridSpots = new Set();\n  let tokensDisplaced = 0;  // Track how many tokens were displaced due to walls/collisions\n  \n  // Get the formation's natural facing direction\n  const naturalFacing = partyToken.document.getFlag('party-vision', 'naturalFacing') || 'north';\n  console.log(`Party Vision | Natural facing: ${naturalFacing}, deploying: ${direction}`);\n  \n  // Party token position in grid coordinates (top-left corner)\n  const partyGridX = partyToken.x / gridSize;\n  const partyGridY = partyToken.y / gridSize;\n  \n  // Calculate the party token's CENTER in grid coordinates\n  const partyTokenWidth = partyToken.document.width;\n  const partyTokenHeight = partyToken.document.height;\n  const partyCenterGridX = partyGridX + (partyTokenWidth / 2);\n  const partyCenterGridY = partyGridY + (partyTokenHeight / 2);\n  \n  console.log(`Party Vision | Deploying at grid center (${partyCenterGridX}, ${partyCenterGridY}) facing ${direction}`);\n  \n  const newTokensData = [];\n  \n  // Find the leader\n  const leaderData = memberData.find(m => m.isLeader) || memberData[0];\n  \n  // Process leader first\n  let leaderActor = await getActor(leaderData);\n  if (!leaderActor) {\n    ui.notifications.error(`Could not find leader actor: ${leaderData.name}`);\n    return;\n  }\n  \n  // Transform leader's offset based on rotation from natural facing to target direction\n  const leaderTransformed = transformOffset(leaderData.dx, leaderData.dy, naturalFacing, direction);\n  \n  // Calculate leader's center position in grid coordinates\n  const leaderCenterGridX = partyCenterGridX + leaderTransformed.dx;\n  const leaderCenterGridY = partyCenterGridY + leaderTransformed.dy;\n  \n  // Get leader's token data to determine size\n  const leaderProtoToken = leaderActor.prototypeToken;\n  const leaderTokenData = leaderProtoToken.toObject();\n  const leaderWidthGrids = leaderTokenData.width;\n  const leaderHeightGrids = leaderTokenData.height;\n  \n  // Convert from center to top-left corner\n  const leaderGridX = Math.round(leaderCenterGridX - (leaderWidthGrids / 2));\n  const leaderGridY = Math.round(leaderCenterGridY - (leaderHeightGrids / 2));\n  const leaderX = leaderGridX * gridSize;\n  const leaderY = leaderGridY * gridSize;\n  \n  console.log(`Leader: offset (${leaderData.dx}, ${leaderData.dy}) \u2192 (${leaderTransformed.dx}, ${leaderTransformed.dy}) \u2192 grid (${leaderGridX}, ${leaderGridY})`);\n  console.log(`Party Vision | Checking wall collisions from party center (${(partyCenterGridX * gridSize).toFixed(0)}, ${(partyCenterGridY * gridSize).toFixed(0)})`);\n  \n  // Note: Leader doesn't need wall checking since they're placed at party token position\n  // But we still use findValidSpot for consistency and token overlap checking\n  const leaderValidSpot = findValidSpot(leaderGridX, leaderGridY, leaderTokenData, assignedGridSpots, leaderX + (leaderWidthGrids * gridSize / 2), leaderY + (leaderHeightGrids * gridSize / 2), true, partyToken.id);\n  \n  const finalLeaderX = leaderValidSpot.x * gridSize;\n  const finalLeaderY = leaderValidSpot.y * gridSize;\n  \n  const leaderToken = {\n    ...leaderTokenData,\n    x: finalLeaderX,\n    y: finalLeaderY,\n    actorId: leaderActor.id,\n    actorLink: leaderProtoToken.actorLink,\n    name: leaderActor.prototypeToken.name || leaderActor.name,\n    img: leaderActor.prototypeToken.texture?.src || leaderActor.img\n  };\n  \n  // Restore original token lighting for leader if it was stored\n  if (leaderData.originalLight && (leaderData.originalLight.bright > 0 || leaderData.originalLight.dim > 0)) {\n    console.log(`Party Vision | Restoring lighting for leader ${leaderData.name}: bright=${leaderData.originalLight.bright}, dim=${leaderData.originalLight.dim}`);\n    leaderToken.light = leaderData.originalLight;\n  }\n  \n  delete leaderToken.actorData;\n  delete leaderToken.delta;\n  \n  newTokensData.push(leaderToken);\n  assignedGridSpots.add(`${leaderValidSpot.x},${leaderValidSpot.y}`);\n  \n  // Sort other members by distance from center (place closer ones first)\n  const otherMembers = memberData.filter(m => !m.isLeader);\n  const sortedMembers = [...otherMembers].sort((a, b) => \n    (Math.abs(a.dx) + Math.abs(a.dy)) - (Math.abs(b.dx) + Math.abs(b.dy))\n  );\n  \n  // Place other members\n  for (const member of sortedMembers) {\n    const actor = await getActor(member);\n    if (!actor) {\n      console.warn(`Actor not found for member ${member.name}`);\n      continue;\n    }\n    \n    // Get token data\n    const protoToken = actor.prototypeToken;\n    const tokenData = protoToken.toObject();\n    const tokenWidthGrids = tokenData.width;\n    const tokenHeightGrids = tokenData.height;\n    \n    // Transform offset based on rotation from natural facing to target direction\n    const transformed = transformOffset(member.dx, member.dy, naturalFacing, direction);\n    \n    console.log(`${member.name}: offset (${member.dx}, ${member.dy}) \u2192 (${transformed.dx}, ${transformed.dy})`);\n    \n    // Calculate target CENTER position in grid coordinates\n    const targetCenterGridX = partyCenterGridX + transformed.dx;\n    const targetCenterGridY = partyCenterGridY + transformed.dy;\n    \n    // Convert from center to top-left corner for token placement\n    const idealGridX = Math.round(targetCenterGridX - (tokenWidthGrids / 2));\n    const idealGridY = Math.round(targetCenterGridY - (tokenHeightGrids / 2));\n    \n    // Find valid spot (checks for token overlaps AND wall collisions)\n    const validSpot = findValidSpot(idealGridX, idealGridY, tokenData, assignedGridSpots, partyCenterGridX * gridSize, partyCenterGridY * gridSize, false, partyToken.id);\n    if (validSpot.displaced) tokensDisplaced++;\n    assignedGridSpots.add(`${validSpot.x},${validSpot.y}`);\n    \n    const finalX = validSpot.x * gridSize;\n    const finalY = validSpot.y * gridSize;\n    \n    console.log(`  \u2192 Final position: grid (${validSpot.x}, ${validSpot.y})`);\n    \n    // Create token data\n    // CRITICAL: Restore original token lighting that was set directly on the token\n    // This preserves lighting that was set on the token itself (not from actor prototype)\n    const newToken = {\n      ...tokenData,\n      x: finalX,\n      y: finalY,\n      actorId: actor.id,\n      actorLink: protoToken.actorLink,\n      name: actor.prototypeToken.name || actor.name,\n      img: actor.prototypeToken.texture?.src || actor.img\n    };\n    \n    // Restore original token lighting if it was stored\n    if (member.originalLight && (member.originalLight.bright > 0 || member.originalLight.dim > 0)) {\n      console.log(`Party Vision | Restoring lighting for ${member.name}: bright=${member.originalLight.bright}, dim=${member.originalLight.dim}`);\n      newToken.light = member.originalLight;\n    }\n    \n    delete newToken.actorData;\n    delete newToken.delta;\n    \n    newTokensData.push(newToken);\n  }\n  \n  // Create all tokens\n  await canvas.scene.createEmbeddedDocuments(\"Token\", newTokensData);\n  \n  // Delete party token\n  await canvas.scene.deleteEmbeddedDocuments(\"Token\", [partyToken.id]);\n  \n  let message = `Party deployed: ${newTokensData.length} members facing ${direction}!`;\n  if (tokensDisplaced > 0) {\n    message += ` (${tokensDisplaced} repositioned due to walls/obstacles)`;\n  }\n  ui.notifications.info(message);\n}\n\n/**\n * Transform an offset based on rotation from natural facing to target direction\n * @param {number} dx - Original x offset in grid units\n * @param {number} dy - Original y offset in grid units\n * @param {string} fromDirection - The formation's natural facing direction\n * @param {string} toDirection - The desired deployment direction\n * @returns {{dx: number, dy: number}} Transformed offset\n */\nfunction transformOffset(dx, dy, fromDirection, toDirection) {\n  // If no rotation needed, return as-is\n  if (fromDirection === toDirection) {\n    return { dx: dx, dy: dy };\n  }\n  \n  // Calculate how many 90-degree clockwise rotations we need\n  const directions = ['north', 'east', 'south', 'west'];\n  const fromIndex = directions.indexOf(fromDirection);\n  const toIndex = directions.indexOf(toDirection);\n  \n  if (fromIndex === -1 || toIndex === -1) {\n    console.warn(`Unknown direction: from=${fromDirection}, to=${toDirection}`);\n    return { dx: dx, dy: dy };\n  }\n  \n  // Calculate rotation steps (how many 90\u00b0 CW rotations)\n  let rotationSteps = (toIndex - fromIndex + 4) % 4;\n  \n  // Apply the rotation\n  let newDx = dx;\n  let newDy = dy;\n  \n  for (let i = 0; i < rotationSteps; i++) {\n    // Rotate 90\u00b0 clockwise: (x, y) -> (-y, x)\n    const temp = newDx;\n    newDx = -newDy;\n    newDy = temp;\n  }\n  \n  return { dx: newDx, dy: newDy };\n}\n\n/**\n * Get an actor from member data, trying UUID first, then ID\n */\nasync function getActor(memberData) {\n  let actor = null;\n  \n  if (memberData.actorUuid) {\n    try {\n      actor = await fromUuid(memberData.actorUuid);\n    } catch (e) {\n      console.warn(`Could not resolve actor UUID ${memberData.actorUuid}`);\n    }\n  }\n  \n  if (!actor) {\n    actor = game.actors.get(memberData.actorId);\n  }\n  \n  return actor;\n}\n\nfunction findValidSpot(idealX, idealY, tokenData, assignedSpots, partyCenterX, partyCenterY, isLeader = false, partyTokenId = null) {\n  if (isSpotValid(idealX, idealY, tokenData, assignedSpots, partyCenterX, partyCenterY, isLeader, partyTokenId)) {\n    return { x: idealX, y: idealY, displaced: false };\n  }\n  \n  // Spiral search for nearby valid spots\n  for (let r = 1; r < 20; r++) {\n    for (let x = idealX - r; x <= idealX + r; x++) {\n      for (let y = idealY - r; y <= idealY + r; y++) {\n        // Only check the perimeter of the current radius\n        if (Math.abs(x - idealX) !== r && Math.abs(y - idealY) !== r) continue;\n        if (isSpotValid(x, y, tokenData, assignedSpots, partyCenterX, partyCenterY, isLeader, partyTokenId)) {\n          console.log(`Party Vision | Token displaced from (${idealX}, ${idealY}) to (${x}, ${y}) due to collision`);\n          return { x, y, displaced: true };\n        }\n      }\n    }\n  }\n  \n  // If no valid spot found after searching, place at ideal spot anyway\n  console.warn(`Party Vision | No valid spot found near (${idealX}, ${idealY}), placing anyway`);\n  return { x: idealX, y: idealY, displaced: true };\n}\n\nfunction isSpotValid(gridX, gridY, tokenData, assignedSpots, partyCenterX, partyCenterY, isLeader = false, partyTokenId = null) {\n  const gridSize = canvas.scene.grid.size;\n  const finalX = gridX * gridSize;\n  const finalY = gridY * gridSize;\n  \n  // Check if this spot is already assigned to another party member\n  if (assignedSpots.has(`${gridX},${gridY}`)) {\n    return false;\n  }\n  \n  const tokenWidth = tokenData.width * gridSize;\n  const tokenHeight = tokenData.height * gridSize;\n  \n  // Calculate the center of the token at this position\n  const tokenCenterX = finalX + (tokenWidth / 2);\n  const tokenCenterY = finalY + (tokenHeight / 2);\n  \n  // Check for walls between party token center and this position's center\n  // Skip this check for the leader since they're placed at the party token position\n  if (!isLeader && partyCenterX !== undefined && partyCenterY !== undefined) {\n    const hasWallBetween = checkWallCollision(\n      { x: partyCenterX, y: partyCenterY },\n      { x: tokenCenterX, y: tokenCenterY }\n    );\n    \n    if (hasWallBetween) {\n      console.log(`Party Vision | Wall detected between party center (${partyCenterX.toFixed(0)}, ${partyCenterY.toFixed(0)}) and position (${tokenCenterX.toFixed(0)}, ${tokenCenterY.toFixed(0)})`);\n      return false;\n    }\n  }\n  \n  // Check for token overlaps with existing tokens on the scene\n  for (const token of canvas.tokens.placeables) {\n    // Skip the party token itself - we're about to delete it\n    if (partyTokenId && token.id === partyTokenId) {\n      continue;\n    }\n    \n    const tokenRect = {\n      x: token.x,\n      y: token.y,\n      width: token.document.width * gridSize,\n      height: token.document.height * gridSize\n    };\n    const newRect = {\n      x: finalX,\n      y: finalY,\n      width: tokenWidth,\n      height: tokenHeight\n    };\n    \n    // AABB (Axis-Aligned Bounding Box) collision check\n    if (tokenRect.x < newRect.x + newRect.width &&\n        tokenRect.x + tokenRect.width > newRect.x &&\n        tokenRect.y < newRect.y + newRect.height &&\n        tokenRect.y + tokenRect.height > newRect.y) {\n      return false; // Collision detected\n    }\n  }\n  \n  // Spot is valid (no overlaps or walls)\n  return true;\n}\n\n/**\n * Check if there's a wall between two points (Foundry v13 compatible)\n * @param {Object} origin - Starting point {x, y}\n * @param {Object} destination - End point {x, y}\n * @returns {boolean} True if wall blocks the path\n */\nfunction checkWallCollision(origin, destination) {\n  // Create bounding box for the path with some padding\n  const padding = 50; // pixels\n  const minX = Math.min(origin.x, destination.x) - padding;\n  const maxX = Math.max(origin.x, destination.x) + padding;\n  const minY = Math.min(origin.y, destination.y) - padding;\n  const maxY = Math.max(origin.y, destination.y) + padding;\n  \n  // Check walls, but only those within the bounding box\n  for (const wall of canvas.walls.placeables) {\n    // Only check walls that block movement\n    if (wall.document.move === CONST.WALL_SENSE_TYPES.NONE) {\n      continue; // This wall doesn't block movement\n    }\n    \n    // Get wall endpoints\n    const wallCoords = wall.document.c;\n    const wallA = { x: wallCoords[0], y: wallCoords[1] };\n    const wallB = { x: wallCoords[2], y: wallCoords[3] };\n    \n    // Quick bounding box check - skip walls that are nowhere near our path\n    const wallMinX = Math.min(wallA.x, wallB.x);\n    const wallMaxX = Math.max(wallA.x, wallB.x);\n    const wallMinY = Math.min(wallA.y, wallB.y);\n    const wallMaxY = Math.max(wallA.y, wallB.y);\n    \n    // Skip if wall's bounding box doesn't overlap with path's bounding box\n    if (wallMaxX < minX || wallMinX > maxX || wallMaxY < minY || wallMinY > maxY) {\n      continue; // Wall is too far away to matter\n    }\n    \n    // Check if the line from origin to destination intersects with this wall\n    const intersects = foundry.utils.lineSegmentIntersects(\n      origin, destination,\n      wallA, wallB\n    );\n    \n    if (intersects) {\n      console.log(`Party Vision | Wall intersection detected at wall (${wallA.x}, ${wallA.y}) to (${wallB.x}, ${wallB.y})`);\n      return true; // Wall blocks the path\n    }\n  }\n  \n  return false; // No walls block the path\n}\n", "folder": null, "sort": 0, "ownership": {"default": 0}, "flags": {}, "_stats": {"systemId": null, "systemVersion": null, "coreVersion": null, "createdTime": null, "modifiedTime": null, "lastModifiedBy": null}}
